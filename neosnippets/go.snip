snippet     helloworld
abbr        package main\nimport fmt...
options     head
  package main

  import (
    "fmt"
  )

  func main() {
    fmt.Printf("Hello, world\n")
  }

snippet     func
abbr        func ...() { ... }
options     head
  func ${1:fname}(${2}) ${3:int }{
    ${0:TARGET:return }
  }

snippet     import
options     head
  import (
    "${1:fmt}"
  )
  ${0:TARGET}

snippet     package
options     head
  package ${1:main}
  ${0:TARGET}

snippet     printf
options     word
  fmt.Printf("${1}\n"${2:})

snippet     println
options     word
  fmt.Println(${0:TARGET})

snippet     struct
options     head
  type ${1} struct {
    ${0:TARGET}
  }

snippet     interface
options     head
  type ${1} interface {
    ${0:TARGET}
  }

snippet     for
options     head
  for ${1} {
    ${0:TARGET}
  }

snippet     range
abbr        for range
options     head
  for ${1:v} := range ${2:#:iterator} {
    ${0:TARGET}
  }

snippet     if
options     head
    if ${1:err != nil} {
        ${0:TARGET}
    }

snippet     switch
abbr        switch {}
options     head
  switch ${1:#:v} {
  case ${2:#:condition}:
    ${0:TARGET}
  }

snippet     select
abbr        select {}
options     head
  select {
  case ${1:#:condition}:
    ${0:TARGET}
  }

snippet     case
options     head
  case ${1:#:condition}:
    ${2:TARGET}


# ------------------ Build-in functions

snippet     close
abbr        func(c chan<- Type)
options     word
  close(${0})

snippet     len
abbr        func(v Type) int
options     word
  len(${0})

snippet     cap
abbr        func(v Type) int
options     word
  cap(${0})

snippet     new
abbr        func(Type) *Type
options     word
  new(${0})

snippet     make
abbr        func(Type, size IntegerType) Type
options     word
  make(${1:[]int}, ${0})

snippet     make-slice
abbr        func(Type, size IntegerType) Type
options     word
  make([]${1:int}, ${0})

snippet     make-map
abbr        func(Type, size IntegerType) Type
options     word
  make(map[${1:string}]${2:string}, ${0})

snippet     make-chan
abbr        func(Type, size IntegerType) Type
options     word
  make(chan ${1:string}, ${0})

snippet     append
abbr        func(slice []Type, elems ...Type) []Type
options     word
  ${1:slice} = append($1, ${2:TARGET})

snippet     copy
abbr        func(dest, src []Type) int
options     word
  copy(${1:DEST}, ${2:SOURCE})

snippet     delete
abbr        func(m map[Type]Type1, key Type)
options     word
  delete(${1:TARGET}, ${2:Key})

snippet     complex
abbr        func(r, i FloatType) ComplexType
options     word
  complex(${1:REAL}, ${2:IMAG})

snippet     real
abbr        func(c ComplexType) FloatType
options     word
  real(${1:COMPLEX})

snippet     imag
abbr        func(c ComplexType) FloatType
options     word
  imag(${1:COMPLEX})

snippet     panic
abbr        func(v interface{})
options     word
  panic(${1:err})

snippet     recover
abbr        func() interface{}
options     word
  recover()
# shorthand variable declaration
snippet v
    ${1} := ${2}
# variable initialization
snippet vr
    var ${1:t} ${0:string}
# variable declaration
snippet var
    var ${1} ${2} = ${3}
# variables declaration
snippet vars
    var (
        ${1} ${2} = ${3}
    )
# append
snippet ap
    append(${1:slice}, ${0:value})
# bool
snippet bl
    bool
# byte
snippet bt
    byte
# break
snippet br
    break
# channel
snippet ch
    chan ${0:int}
# case
snippet cs
    case ${1:value}:
        ${0}
# const
snippet c
    const ${1:NAME} = ${0:0}
# constants with iota
snippet co
    const (
        ${1:NAME1} = iota
        ${0:NAME2}
    )
# continue
snippet cn
    continue
# defer
snippet df
    defer ${0:func}()
# defer recover
snippet dfr
    defer func() {
        if err := recover(); err != nil {
            ${0}
        }
    }()
# gpl
snippet gpl
    /*
     * This program is free software; you can redistribute it and/or modify
     * it under the terms of the GNU General Public License as published by
     * the Free Software Foundation; either version 2 of the License, or
     * (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, see <http://www.gnu.org/licenses/>.
     *
     * Copyright (C) ${1:Author}, `strftime("%Y")`
     */

    ${0}
# int
snippet i
    int
# import
snippet im
    import (
        "${1:package}"
    )
# interface
snippet in
    interface{}
# full interface snippet
snippet inf
    interface ${1:name} {
        ${2:/* methods */}
    }
# if condition
snippet if
    if ${1:/* condition */} {
        ${2}
    }
# else snippet
snippet el
    else {
        ${1}
    }
# error snippet
snippet ir
    if err != nil {
        return err
    }
    ${0}
# false
snippet f
    false
# fallthrough
snippet ft
    fallthrough
# float
snippet fl
    float32
# float32
snippet f3
    float32
# float64
snippet f6
    float64
# if else
snippet ie
    if ${1:/* condition */} {
        ${2}
    } else {
        ${3}
    }
    ${0}
# for loop
snippet fo
    for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
        ${4}
    }
    ${0}
# for range loop
snippet fr
    for ${1:k}, ${2:v} := range ${3} {
        ${4}
    }
    ${0}
# function simple
snippet fun
    func ${1:funcName}(${2}) ${3:error} {
        ${4}
    }
    ${0}
# function on receiver
snippet fum
    func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
        ${6}
    }
    ${0}
# log printf
snippet lf
    log.Printf("%${1:s}", ${2:var})
# log printf
snippet lp
    log.Println("${1}")
# make
snippet mk
    make(${1:[]string}, ${0:0})
# map
snippet mp
    map[${1:string}]${0:int}
# main()
snippet main
    func main() {
        ${1}
    }
    ${0}
# new
snippet nw
    new(${0:type})
# package
snippet pa
    package ${1:main}
# panic
snippet pn
    panic("${0:msg}")
# print
snippet pr
    fmt.Printf("%${1:s}\n", ${2:var})
# range
snippet rn
    range ${0}
# return
snippet rt
    return ${0}
# result
snippet rs
    result
# select
snippet sl
    select {
    case ${1:v1} := <-${2:chan1}
        ${3}
    case ${4:v2} := <-${5:chan2}
        ${6}
    default:
        ${0}
    }
# string
snippet sr
    string
# struct
snippet st
    struct ${1:name} {
        ${2:/* data */}
    }
    ${0}
# switch
snippet sw
    switch ${1:var} {
    case ${2:value1}:
        ${3}
    case ${4:value2}:
        ${5}
    default:
        ${0}
    }
snippet sp
    fmt.Sprintf("%${1:s}", ${2:var})
# true
snippet t
    true
# goroutine named function
snippet g
    go ${1:funcName}(${0})
# goroutine anonymous function 
snippet ga
    go func(${1} ${2:type}) {
        ${3:/* code */}
    }(${0})
snippet test test function
    func Test${1:name}(t *testing.T) {
        ${2}
    }
    ${0}
snippet bench benchmark function
    func Benchmark${1:name}(b *testing.B) {
        for i := 0; i < b.N; i++ {
            ${2}
        }
    }
    ${0}

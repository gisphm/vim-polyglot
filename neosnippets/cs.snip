# Structure
snippet namespace
alias   name
abbr    namespace {}
options head
    namespace ${1:#:Name} {
        ${0:TARGET}
    }

snippet class
abbr    class {}
    class ${1:#:Name} ${2::} ${3:Parent}${4:,} ${5:Interface} {
        ${0:TARGET}
    }

snippet struct
abbr    struct {}
    struct ${1:#:Name} ${2::} ${3:Interface} {
        ${0:TARGET}
    }

snippet interface
abbr    interface {}
    interface ${1:#:IName} ${2::} ${3:Parent} {
        ${0:TARGET}
    }

snippet method
    ${1:void} ${2:#:Method}(${3:#:arguments}) {
        ${0:TARGET}
    }

snippet enum
abbr    enum {}
    enum ${1:#:Name} {
        ${0:TARGET}
    }


# Declare
snippet delegate
    delegate ${1:void} ${2:#:Delegate}(${3:#:arguments});${0}

snippet property
alias   prop
    ${1:int} ${2:#:Name} { get${3:;} ${4:#:private }set${5:;} }${0}

snippet get
abbr    get {}
    get {${1:TARGET}}${0}

snippet set
abbr    set {}
    set {${1:TARGET}}${0}


# PreProcess Syntax
snippet define
alias   def
options head
    #define ${0:#:SYMBOL}

snippet undef
alias   und
options head
    #undef ${0:#:SYMBOL}

snippet ifdef
options head
    #if ${1:SYMBOL}
        ${0:TARGET}
    #endif

snippet warning
alias   warn
options head
    #warning ${0:#:message}

snippet error
alias   err
options head
    #error ${0:#:message}

snippet line
options head
    #line ${0:#:number}

snippet region
alias   reg
options head
    #region ${1:#:name}
        ${0:TARGET}
    #endregion

snippet pragma_warning
alias   pragma pragma_warn
options head
    #pragma warning ${2:disable} ${3:#:errno}


# Syntax
snippet if
abbr    if () {}
    if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet elseif
alias   elif
abbr    else if () {}
    else if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet ifelse
alias   ifel
abbr    if () {} else {}
    if (${1:#:condition}) {
        ${2:TARGET}
    } else {
        ${3:TARGET}
    }

snippet while
abbr    while () {}
    while (${1:#:condition}) {
        ${0:TARGET}
    }

snippet do_while
alias   dowhile
abbr    do {} while() {}
    do {
        ${0:TARGET}
    } while (${1:#:condition});

snippet for
abbr    for () {}
    for (${1:#:var}; ${2:#:condition}; ${3:#:effect}) {
        ${0:TARGET}
    }

snippet foreach
alias   fore
abbr    foreach () {}
    foreach (${1:#:var} in ${2:#:iter}) {
        ${0:TARGET}
    }

snippet switch
abbr    switch () {}
    switch (${1:#:var}) {
    case ${2:#:val}:
        ${0:TARGET}
        break;
    }

snippet case
options head
    case ${1:#:val}:
        ${0:TARGET}
        break;

snippet break
options head
    break;

snippet goto
options head
    goto case ${1:#:Val};${0}

snippet default
options head
    default:
        ${0:TARGET}
        break;

snippet try_without_catch_nor_finally
alias   try_n
options head
    try {
        ${0:TARGET}
    }

snippet try_catch
alias   try
abbr    try {} catch () {}
options head
    try {
        ${0:TARGET}
    } catch (${1:Exception} ${2:e}) {
        ${3:Console.WriteLine(e.Message);}
    }

snippet try_catch_n
alias   try_cn
abbr    try {} catch {}
options head
    try {
        ${0:TARGET}
    } catch {
        ${1}
    }

snippet try_catch_finally
alias   try_cf
abbr    try {} catch () {} finally {}
options head
    try {
        ${0:TARGET}
    } catch (${1:Exception} ${2:e}) {
        ${3:Console.WriteLine(e.Message);}
    } finally {
        ${4}
    }

snippet try_finally
alias   try_f
abbr    try {} finally {}
options head
    try {
        ${0:TARGET}
    } finally {
        ${1}
    }

snippet try_catch_n_finally
alias   try_cnf
abbr    try {} catch {} finally {}
options head
    try {
        ${0:TARGET}
    } catch {
        ${1}
    } finally {
        ${2}
    }

snippet catch
abbr    catch () {}
    catch (${1:Exception} ${2:e}) {
        ${0:Console.WriteLine(e.Message);}
    }

snippet catch_n
abbr    catch {}
    catch {
        ${0}
    }

snippet finally
alias   fin
abbr    finally {}
    finally {
        ${0:TARGET}
    }

snippet throw
options head
    throw ${0:#:exception}

snippet lock
abbr    lock () {}
options head
    lock (${1:#:resource}) {
        ${0:TARGET}
    }

snippet using_resource
alias   using resource
abbr    using () {}
options head
    using (${1:#:resource}) {
        ${0:TARGET}
    }

snippet checked
abbr    checked () {}
options head
    checked (${1:#:var}) {
        ${0:TARGET}
    }

snippet unchecked
abbr    unchecked () {}
options head
    unchecked (${1:#:var}) {
        ${0:TARGET}
    }

snippet unsafe
abbr    unsafe {}
options head
    unsafe {
        ${0:TARGET}
    }

snippet fixed
abbr    fixed () {}
options head
    fixed (${1:#:type}* ${2:#:var} = ${3:#:adress}) {
        ${0:TARGET}
    }

snippet using_import
alias   import
options head
    using ${1:#:path};${0}

snippet using_typedef
alias   typedef
options head
    using ${1:Name} = ${2:Type};${0}


# Import Path
snippet s.l
    System.Linq

snippet s.c.g
    System.Collections.Generic

snippet s.t
    System.Text

snippet s.i
    System.IO

snippet s.d
    System.Diagnostics

snippet s.r.c
    System.Runtie.CompilerServices

snippet s.w.f
    System.Windows.Forms


# Attribute
snippet serializable
alias   serial
options head
    [SerializableAttribute]

snippet conditional
alias   cond
options head
    [Conditional("${1:#:SYMBOL}")]${0}

snippet obsolete
alias   obs dep deprecated
options head
    [Obsolete("${1:#:description}")]${0}

snippet asm_internals_visible_to
alias   internals asmInternalsVisibleTo friend_attr
options head
    [assembly: InternalsVisibleTo("${1:#:FriendName}")]${0}


#XML Document
snippet c
abbr    <c></c>
    <c>${1:#:text}</c>

snippet code
abbr    <code></code>
    <code>${0:#:content}</code>

snippet example
abbr    <example></example>
    <example>${0:#:description}</example>

snippet exception
abbr    <exception cref=""></exception>
    <exception cref="${1:#:class}">${2:#:description}</exception>

snippet include
abbr    <include file='' path=''/>
    <include file='${1:#:filename}' path='${2:#:tabpath}[@${3:#:name}="${4:#:id}"]'/>

snippet param
abbr    <param name=""></param>
    <param name="${1:#:name}">${0:#:description}</param>

snippet paramref
abbr    <paramref name=""/>
    <paramref name="${1:#:name}"/>

snippet returns
abbr    <returns></returns>
    <returns>${0:#:description}</returns>

snippet remarks
abbr    <remarks></remarks>
    <remarks>${0:#:description}</remarks>

snippet see
abbr    <see cref=""/>
    <see cref="${1:#:member}"/>

snippet seealso
abbr    <seealso cref=""/>
    <seealso cref="${1:#:member}"/>}

snippet summary
abbr    <summary></summary>
    <summary>${0:#:description}</summary>

snippet typeparam
abbr    <typeparam name=""></typeparam>
    <typeparam name="${1:#:name}">${0:#:description}</typeparam>

snippet typeparamref
abbr    <typeparamref name=""/>
    <typeparamref name="${1:#:name}"/>

snippet value
abbr    <value></value>
    <value>${0:#:description}</value>


# Other
snippet main
options head
    public static void Main(string[] args) {
        ${0}
    }

snippet writeline
alias   println p
options head
    Console.WriteLine(${1:#:message});${0}

snippet write
alias   print
options head
    Console.Write(${1:#:message});${0}

snippet helloworld
options head
    public class ${1:Hello} {
        public static void Main(string[] args) {
            System.Console.WriteLine("Hello, world!");
        }
    }


# NUnit
snippet testclass
alias   tc
options head
    [TestFixture]
    public class ${1}Test {
        ${0:TARGET}
    }

snippet testsetup
alias   tsu
options head
    [SetUp]
    public void SetUp() {
        ${0:TARGET}
    }

snippet testteardown
alias   ttd
options head
    [TearDown]
    public void TearDown() {
        ${0:TARGET}
    }

snippet test
options head
    [Test]
    public void ${1:#:Name}Test() {
        ${0:TARGET}
    }

snippet category
options head
    [Category("${0:#:category}")]
# cs.snippets
# ===========
#
# Standard C-Sharp snippets for snipmate.
#
# Largely ported over from Visual Studio 2010 snippets plus
# a few snippets from Resharper plus a few widely known snippets.
#
# Most snippets on elements (i.e. classes, properties)
# follow suffix conventions. The order of suffixes to a snippet
# is fixed.
#
# Snippet Suffix Order
# --------------------
# 1. Access Modifiers
# 2. Class Modifiers
#
# Access Modifier Suffix Table
# ----------------------------
# + = public
# & = internal
# | = protected
# - = private
#
# Example: `cls&` expands to `internal class $1`.
# Access modifiers might be doubled to indicate
# different modifiers for get/set on properties.
# Example: `pb+-` expands to `public bool $1 { get; private set; }`
#
# Class Modifier Table
# --------------------
# ^ = static
# % = abstract
#
# Example: `cls|%` expands to `protected abstract class $1`
#
# On method and property snippets, you can directly set
# one of the common types int, string and bool, if desired,
# just by appending the type modifier.
#
# Type Modifier Table
# -------------------
# i = integer
# s = string
# b = bool
#
# Example: `pi+&` expands to `public int $1 { get; internal set; }`
#
# I'll most propably add more stuff in here like
# * List/Array constructio
# * Mostly used generics
# * Linq
# * Funcs, Actions, Predicates
# * Lambda
# * Events
#
# Feedback is welcome!
#
# Main 
snippet sim
    ${1:public }static int Main(string[] args) {
        ${0}
        return 0;
    }
snippet simc
    public class Application {
        ${1:public }static int Main(string[] args) {
            ${0}
            return 0;
        }
    }
snippet svm
    ${1:public }static void Main(string[] args) {
        ${0}
    }
# if condition
snippet if
    if (${1:true}) {
        ${0}
    }
snippet el
    else {
        ${0}
    }
snippet ifs
    if (${1})
        ${0}
# ternary conditional
snippet t
    ${1} ? ${2} : ${0}
snippet ?
    ${1} ? ${2} : ${0}
# do while loop
snippet do
    do {
        ${0}
    } while (${1:true});
# while loop
snippet wh
    while (${1:true}) {
        ${0}
    }
# for loop
snippet for
    for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++}) {
        ${0}
    }
snippet forr
    for (int ${1:i} = ${2:length}; $1 >= 0; $1--) {
        ${0}
    }
# foreach
snippet fore
    foreach (${1:var} ${2:entry} in ${3}) {
        ${0}
    }
snippet foreach
    foreach (${1:var} ${2:entry} in ${3}) {
        ${0}
    }
snippet each
    foreach (${1:var} ${2:entry} in ${3}) {
        ${0}
    }
# interfaces
snippet interface
    public interface ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet if+
    public interface ${1:`vim_snippets#Filename()`} {
        ${0}
    }
# class bodies
snippet class
    public class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls
    ${2:public} class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls+
    public class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls+^
    public static class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls&
    internal class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls&^
    internal static class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls|
    protected class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
snippet cls|%
    protected abstract class ${1:`vim_snippets#Filename()`} {
        ${0}
    }
# constructor
snippet ctor
    public ${1:`vim_snippets#Filename()`}() {
        ${0}
    }
# properties - auto properties by default.
# default type is int with layout get / set.
snippet prop
    ${1:public} ${2:int} ${3} { get; set; }
snippet p
    ${1:public} ${2:int} ${3} { get; set; }
snippet p+
    public ${1:int} ${2} { get; set; }
snippet p+&
    public ${1:int} ${2} { get; internal set; }
snippet p+|
    public ${1:int} ${2} { get; protected set; }
snippet p+-
    public ${1:int} ${2} { get; private set; }
snippet p&
    internal ${1:int} ${2} { get; set; }
snippet p&|
    internal ${1:int} ${2} { get; protected set; }
snippet p&-
    internal ${1:int} ${2} { get; private set; }
snippet p|
    protected ${1:int} ${2} { get; set; }
snippet p|-
    protected ${1:int} ${2} { get; private set; }
snippet p-
    private ${1:int} ${2} { get; set; }
# property - bool
snippet pi
    ${1:public} int ${2} { get; set; }
snippet pi+
    public int ${1} { get; set; }
snippet pi+&
    public int ${1} { get; internal set; }
snippet pi+|
    public int ${1} { get; protected set; }
snippet pi+-
    public int ${1} { get; private set; }
snippet pi&
    internal int ${1} { get; set; }
snippet pi&|
    internal int ${1} { get; protected set; }
snippet pi&-
    internal int ${1} { get; private set; }
snippet pi|
    protected int ${1} { get; set; }
snippet pi|-
    protected int ${1} { get; private set; }
snippet pi-
    private int ${1} { get; set; }
# property - bool
snippet pb
    ${1:public} bool ${2} { get; set; }
snippet pb+
    public bool ${1} { get; set; }
snippet pb+&
    public bool ${1} { get; internal set; }
snippet pb+|
    public bool ${1} { get; protected set; }
snippet pb+-
    public bool ${1} { get; private set; }
snippet pb&
    internal bool ${1} { get; set; }
snippet pb&|
    internal bool ${1} { get; protected set; }
snippet pb&-
    internal bool ${1} { get; private set; }
snippet pb|
    protected bool ${1} { get; set; }
snippet pb|-
    protected bool ${1} { get; private set; }
snippet pb-
    private bool ${1} { get; set; }
# property - string
snippet ps
    ${1:public} string ${2} { get; set; }
snippet ps+
    public string ${1} { get; set; }
snippet ps+&
    public string ${1} { get; internal set; }
snippet ps+|
    public string ${1} { get; protected set; }
snippet ps+-
    public string ${1} { get; private set; }
snippet ps&
    internal string ${1} { get; set; }
snippet ps&|
    internal string ${1} { get; protected set; }
snippet ps&-
    internal string ${1} { get; private set; }
snippet ps|
    protected string ${1} { get; set; }
snippet ps|-
    protected string ${1} { get; private set; }
snippet ps-
    private string ${1} { get; set; }
# members - void
snippet m
    ${1:public} ${2:void} ${3}(${4}) {
        ${0}
    }
snippet m+
    public ${1:void} ${2}(${3}) {
        ${0}
    }
snippet m&
    internal ${1:void} ${2}(${3}) {
        ${0}
    }
snippet m|
    protected ${1:void} ${2}(${3}) {
        ${0}
    }
snippet m-
    private ${1:void} ${2}(${3}) {
        ${0}
    }
# members - int
snippet mi
    ${1:public} int ${2}(${3}) {
        ${0:return 0;}
    }
snippet mi+
    public int ${1}(${2}) {
        ${0:return 0;}
    }
snippet mi&
    internal int ${1}(${2}) {
        ${0:return 0;}
    }
snippet mi|
    protected int ${1}(${2}) {
        ${0:return 0;}
    }
snippet mi-
    private int ${1}(${2}) {
        ${0:return 0;}
    }
# members - bool
snippet mb
    ${1:public} bool ${2}(${3}) {
        ${0:return false;}
    }
snippet mb+
    public bool ${1}(${2}) {
        ${0:return false;}
    }
snippet mb&
    internal bool ${1}(${2}) {
        ${0:return false;}
    }
snippet mb|
    protected bool ${1}(${2}) {
        ${0:return false;}
    }
snippet mb-
    private bool ${1}(${2}) {
        ${0:return false;}
    }
# members - string
snippet ms
    ${1:public} string ${2}(${3}) {
        ${0:return "";}
    }
snippet ms+
    public string ${1}(${2}) {
        ${0:return "";}
    }
snippet ms&
    internal string ${1}(${2}) {
        ${0:return "";}
    }
snippet ms|
    protected string ${1:}(${2:}) {
        ${0:return "";}
    }
snippet ms-
    private string ${1}(${2}) {
        ${0:return "";}
    }
# structure
snippet struct
    public struct ${1:`vim_snippets#Filename()`} {
        ${0}
    }
# enumeration
snippet enum
    enum ${1} {
        ${0}
    }
    
snippet enum+
    public enum ${1} {
        ${0}
    }
# preprocessor directives
snippet #if
    #if
        ${0}
    #endif
# inline xml documentation
snippet ///
    /// <summary>
    /// ${0}
    /// </summary>
snippet <p
    <param name="${1}">${2:$1}</param>
snippet <ex
    <exception cref="${1:System.Exception}">${2}</exception>
snippet <r
    <returns>${1}</returns>{
snippet <s
    <see cref="${1}"/>
snippet <rem
    <remarks>${1}</remarks>
snippet <c
    <code>${1}</code>

snippet cw
    Console.WriteLine(${1});

# equals override
snippet eq
    public override bool Equals(object obj) {
        if (obj == null || GetType() != obj.GetType()) {
            return false;
        }
        ${0:throw new NotImplementedException();}
        return base.Equals(obj);
    }
# exception 
snippet exc
    public class ${1:MyException} : ${2:Exception} {
        public $1() { }
        public $1(string message) : base(message) { }
        public $1(string message, Exception inner) : base(message, inner) { }
        protected $1(
            System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context)
                : base(info, context) { }
    }
# indexer 
snippet index
    public ${1:object} this[${2:int} index] {
        get { ${0} }
        set { ${0} }
    }
# eventhandler 
snippet inv
    EventHandler temp = ${1:MyEvent};
    if (${2:temp} != null) {
        $2();
    }
# lock
snippet lock
    lock (${1:this}) {
        ${0}
    }
# namespace
snippet namespace
    namespace ${1:MyNamespace} {
        ${0}
    }
# property
snippet prop
    public ${1:int} ${2:MyProperty} { get; set; }
snippet propf
    private ${1:int} ${2:myVar};
        public $1 ${3:MyProperty} {
            get { return $2; }
            set { $2 = value; }
        }
snippet propg
    public ${1:int} ${2:MyProperty} { get; private set; }
# switch    
snippet switch
    switch (${1:switch_on}) {
        ${0}
        default:
    }
# try
snippet try
    try {
            ${0}
    }
    catch (${1:System.Exception}) {
            throw;
    }
snippet tryf
    try {
        ${0}
    }
    finally {
        ${1}
    }
# using
snippet usi
    using(${1:resource}) {
        ${0}
    }

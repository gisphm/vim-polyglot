snippet     defn-doc
abbr        defn function "..." [...] ...
options     head
	(defn ${1:name}
		"${2:doc}"
		[${3}]
		${0})

snippet     try
abbr        (try ... (catch ...
	(try
		${1}
		(catch ${2:Exception} e ${3:nil}))

snippet     ref-set
abbr        (dosync (ref-set ...
options     head
	(dosync
		(ref-set ${1:ref} ${2:value}))

# http://tnoda-clojure.tumblr.com/post/24969285880/clojure-scripting
snippet     shebang
options     head
	#^:shebang '[
	exec java -cp \`locate clojure- | grep -P "clojure-[\\d\\.]+\\.jar$" | tail -1\` clojure.main "\$0"
	]
	

snippet     warn
options     head
  (binding [*out* *err*]
    (println ${0:TARGET}))

snippet     defrecord
options     head
  (defrecord ${1:record} [${2:constructor-args}]
    ${3:protocol} (${3:method} [${5}] ${6}))

snippet     deftype
options     head
  (defrecord ${1:type} [${2:constructor-args}]
    ${3:protocol} (${3:method} [${5}] ${6}))

snippet     require-core-match
options     head
  (ns ${1:example}
    (:require [clojure.core.match :as m]))
  ; vim: set lispwords+=m/match :

snippet     deftest
options     head
  (deftest ${1:a}-test
    (testing "${2:hello}"
      ${0:TARGET:(is (= 0 1))}))

snippet     use-strint-in-ns
options     head
  (:require [clojure.core.strint :refer (<<)])

snippet     dir-glob
options     head
  [org.clojars.hozumi/clj-glob "0.1.2"]
  (:require [org.satta.glob :as g])
  (g/glob "${0:TARGET}")

snippet     sleep
  (Thread/sleep ${1})

snippet     defproejct
options     head
	(defproject ${1:aaa} "0.1-SNAPSHOT"
	  :description "FIXME: write description"
	  :url "https://github.com/${2}"
	  :license {:name "GNU GPL v3+"
	            :url "http://www.gnu.org/licenses/gpl-3.0.en.html"}
	  :dependencies [[org.clojure/clojure "1.7.0"]]
	  :main ^:skip-aot ${3:aaa.core}
	  :target-path "target/%s"
	  :min-lein-version "2.3.0")

snippet     ns
options     head
  (ns ${1:`substitute(substitute(substitute(expand('%:p:r'), '.*/\(src\|test\)/', '', ''), '/', '.', 'g'), '_', '-', 'g')`}
    (:require `expand('%:r') =~ '_test$' ? '[clojure.test :refer :all]' : ''`${2:}))

snippet     bench
  (let [bench-before (System/currentTimeMillis)]
    ${1:TARGET}
    (prn 'Took (- (System/currentTimeMillis) bench-before) 'msec))

snippet     private
options     word
  @#'

snippet     java-methods
options     head
  (:members (clojure.reflect/refrect ${1}))
snippet comm
    (comment
        ${0})
snippet condp
    (condp ${1:pred} ${2:expr}
        ${0})
snippet def
    (def ${0})
snippet defm
    (defmethod ${1:multifn} "${2:doc-string}" ${3:dispatch-val} [${4:args}]
        ${0})
snippet defmm
    (defmulti ${1:name} "${2:doc-string}" ${0:dispatch-fn})
snippet defma
    (defmacro ${1:name} "${2:doc-string}" ${0:dispatch-fn})
snippet defn
    (defn ${1:name} "${2:doc-string}" [${3:arg-list}]
        ${0})
snippet defp
    (defprotocol ${1:name}
        ${0})
snippet defr
    (defrecord ${1:name} [${2:fields}]
        ${3:protocol}
        ${0})
snippet deft
    (deftest ${1:name}
        (is (= ${0:assertion})))
snippet is
    (is (= ${1} ${0}))
snippet defty
    (deftype ${1:Name} [${2:fields}]
        ${3:Protocol}
        ${0})
snippet doseq
    (doseq [${1:elem} ${2:coll}]
        ${0})
snippet fn
    (fn [${1:arg-list}] ${0})
snippet if
    (if ${1:test-expr}
        ${2:then-expr}
        ${0:else-expr})
snippet if-let
    (if-let [${1:result} ${2:test-expr}]
        (${3:then-expr} $1)
        (${0:else-expr}))
snippet imp
    (:import [${1:package}])
        & {:keys [${1:keys}] :or {${0:defaults}}}
snippet let
    (let [${1:name} ${2:expr}]
        ${0})
snippet letfn
    (letfn [(${1:name}) [${2:args}]
        ${0})])
snippet map
    (map ${1:func} ${0:coll})
snippet mapl
    (map #(${1:lambda}) ${0:coll})
snippet met
    (${1:name} [${2:this} ${3:args}]
        ${0})
snippet ns
    (ns ${0:name})
snippet dotimes
    (dotimes [_ 10]
        (time
            (dotimes [_ ${1:times}]
                ${0})))
snippet pmethod
    (${1:name} [${2:this} ${0:args}])
snippet refer
    (:refer-clojure :exclude [${0}])
snippet require
    (:require [${1:namespace} :as [${0}]])
snippet use
    (:use [${1:namespace} :only [${0}]])
snippet print
    (println ${0})
snippet reduce
    (reduce ${1:(fn [p n] ${3})} ${2})
snippet when
    (when ${1:test} ${0:body})
snippet when-let
    (when-let [${1:result} ${2:test}]
        ${0:body})
